#!/usr/bin/env ruby
#
# zfs-snapper: Yet another ZFS automatic snapshot management script.
#
# Distinguishing features?
#
# - Doesn't create unnecessary duplicate snapshots.  If you have frequent, hourly,
#   daily, weekly and monthly snapshots, they will share a single one, you won't
#   get five different snapshots with different names.
#
# - Makes extensive use of ZFS user properties to specify what should be
#   snapshotted (and when?)
#
# - Simple.  I'm not writing 30 lines of code to work out whether I can safely
#   call snapshot -r on a root pool when I can just pass the full list with 2.
#   Semantically there appears to be no appreciable difference.
#
# - Cares about snapshot ages, not specific times or dates.  If you want to keep
#   monthly snapshots, it'll make a monthly snapshot the first time it's run set
#   to expire in 31 days, rather than waiting until the first day of the month.
#
# - Create named ad-hoc snapshots that will auto-expire.
#
# - Management commands.  List, hold, destroy, create.
#
# - Automatically add cronjob?
#
# - Minimap dependencies. You need a fairly recent Ruby (2.0+).
#   No gems, no Gemfile, no messing about with bundler, just Ruby.
#   It's all one entirely self-contained script.
#
# - Tested.
#

if RUBY_VERSION.split(".").map(&:to_i)[0] < 2
	abort("Ruby version 2.0+ is required.")
end

require 'optparse'
require 'time'
require 'bigdecimal'
require 'pp'

# Commands = <<EOC
# snapshot
# EOC
# Options = <<EOC
# -s	--snapshot [interval:count[,..]]
# -n	--dry-run	Just say what we'd do.
# -v	--verbose	Print commands and other debug info
# -d	--delay	Add a random delay to the snapshot.
# EOC

# settings = {
# }

# OptionParser.new do |opts|
# 	opts.banner = "Usage: #{$0} [options] [interval[:number of snapshots] ..]"
# 	Options.each do |o|
# 		o = o.split(/\t+/)
# 		opts.on(*o) {|v| o[v[0]] = o }
# 	end
# end

TestSnapshots = []

module Snapper
	Now = Time.new.gmtime     # 
	SnapFormat = 'auto.%F.%RZ' # yyyy-mm-dd.hh:mm

	module CommandRunner
		class Error < StandardError
		end

		def self.zfs(args)
			run([Which[:zfs], *args])
		end

		def self.run(cmd)
			p cmd if $VERBOSE

			r,w = IO.pipe
			out = IO.popen(cmd, err: w){|f| f.read }
			w.close
			err = r.read || ''
			r.close

			if $?.success?
				return out || true
			else
				raise Error, "Error running #{cmd.join(' ').dump}, exit=#{$?.exitstatus}, stderr=\n#{err.gsub(/^/,"> ")}"
			end
		end

		Which = Hash.new do |hash, cmd|
			exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
			ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
				exts.each { |ext|
					exe = File.join(path, "#{cmd}#{ext}")
					if File.executable? exe
						hash[cmd] = exe
						break
					end
				}
			end
			hash[cmd]
		end
	end

	class ZFS
		class Dataset
			Properties = %w(auto).map {|p| "hur.st:snapshot.#{p}" }
			attr_reader :name, :properties, :snapshots
			def initialize(name, properties, snapshots = [])
				@name, @properties, @snapshots = name, properties, snapshots

				@wanted_snapshots = []
			end

			def want_snapshot(interval)
				@wanted_snapshots << interval
			end
		end

		class Snapshot
			Properties = %w(expires_at intervals).map {|p| "hur.st:snapshot.#{p}" }
			attr_reader :dataset, :name, :properties
			def initialize(dataset, name, properties)
				@dataset, @name, @properties = dataset, name, properties
				@created = Time.strptime(name.split('@', 2)[1], SnapFormat)
			end

			def expired?
			end

			def age
			end
		end

		class << self
			#def auto_snapshot_property()    "com.sun:auto-snapshot" end
			def property_namespace()          "st.hur:snapshot" end
			def auto_snapshot_property()      "st.hur:auto-snapshot" end
			def snapshot_intervals_property() "st.hur:snapshot-intervals" end
			def snapshot_expire_property()    "st.hur:snapshot-expires-at" end # if you remove an autosnapshot specification, fallback to this?

			def property(name) "st.hur:snapshot." << name end

			def managed_datasets
				datasets = list(type: %w(filesystem volume), properties: [snapshot_intervals_property, auto_snapshot_property])
				datasets = datasets.select {|name,props| props[auto_snapshot_property] == 'true' }

				# XXX: We may have managed snapshots on datasets without auto-snapshot set.
				datasets = datasets.map.with_object({}) {|(name,props),ds| ds[name] = Dataset.new(name, props) }
				managed_snapshots.each_with_object(datasets) do |(name,props),ds|
					ds[name.split('@', 2)].tap {|dataset| dataset.snapshots << Snapshot.new(dataset, name, props) }
				end
			end

			def managed_snapshots
				snapshots = list(type: 'snapshot', properties: ['used',snapshot_intervals_property,snapshot_expire_property])
				snapshots.select {|name, props| props[snapshot_intervals_property] != '-' }
			end

			def datasets
				dsts = list(type: %w(filesystem volume snapshot), properties: ['used',*Dataset::Properties,*Snapshot::Properties])
				snapshots, filesystems, volumes = dsts.group_by {|name,props| props['type'] }.values_at('snapshot', 'filesystem', 'volume')
				dsts.group_by {|name,props| props['type'] }
			end

			def list(type: %w(filesystem volume), properties: %w())
				properties = ['name', 'type', *properties]
				op = %w(list -S name -H -o)
				op << properties.join(',')
				op += ['-t', Array(type).join(',')] if type
				datasets = CommandRunner.zfs(op).lines.map {|line| line.chomp.split("\t", properties.size) }
				Hash[datasets.map {|name,*props| [name, Hash[properties[1..-1].zip(props)]] }]
			end

			def empty_snapshots
				managed_snapshots.select {|name, props| props['used'] == '0' }
			end
		end
	end

	Interval = Struct.new(:raw, :seconds, :count)
	class Interval
		Periods = {
			1           => %w(s sec secs second seconds secondly),
			60          => %w(m min minute minutes minutely),
			3600        => %w(h hr hour hours hourly),
			3600*24     => %w(d dy day days daily),
			3600*24*7   => %w(wk week weeks weekly),
			3600*24*14  => %w(f fort fortnight fortnightly),
			3600*24*31  => %w(mn mon month months monthly),
			3600*24*356 => %w(y yr year years yearly),
		}

		PeriodRE = /(?:#{Periods.values.flatten.join('|')})/i
		PeriodMap = Periods.map.with_object({}) {|(k,v),h| v.each {|name| h[name] = k } }
		PeriodMap.default_proc = proc {|h,k| raise ArgumentError, "Invalid period: #{k.dump}" }

		def self.parse_intervals(string)
			string.split(/\s*;\s*/).map do |part|
				case part
					# 5 weekly; 5 * weekly; weekly
				when /\A(\d+)?\s*\*?\s*(#{PeriodRE})\z/i
					new(part, PeriodMap[$2.downcase], $1.empty? ? 1 : Integer($1))

					# 5 * 1 week; 5 * 6 week
				when /\A(\d+)\s*\*\s*(\d+(?:\.\d+)?)\s*(#{PeriodRE})\z/i
					new(part, PeriodMap[$3.downcase] * Float($2), Integer($1))

				else
					raise ArgumentError, "Unable to parse interval: #{part.dump}"
				end
			end
		end
	end

	Defaults = {
	}

	def self.run(args)
		while iv = gets.chomp
			intervals = Interval.parse_intervals iv #("4 * 15 minutely; 24 hourly; 7 daily; 4 weekly; 4 * monthly")
			pp intervals
		end

		# ensure not running
		# ..

		datasets  = ZFS.managed_datasets
		# snapshots = ZFS.managed_snapshots
		datasets.each do |name, dataset|
			intervals.each do |name, props|
			#	dataset.snapshots.each do |name, snapshot|
			end
		end
		pp datasets
		exit


		datasets.each do |name, props|
			props[:snapshots] = snapshots[name] || []
		end

		new_snapshots = Hash.new {|h,k| h[k] = [] }
		datasets.each do |dataset|
			intervals.each do |interval|
				
			end
		end
		intervals.each do |interval|
			datasets.each do |dataset|

			end
		end

		empty = ZFS.empty_snapshots
		pp empty

		pp datasets
		pp snapshots
	end
end


snapper = Snapper.run(ARGV)

exit

Now = Time.new

AutoSnapshot = Struct.new(:dataset, :name, :classes, :timestamp, :keep)
class AutoSnapshot
	SnapFormat = 'auto.%F.%R' # yyyy-mm-dd.hh:mm
	def initialize(dataset)
		@dataset = dataset
	end

	def self.parse(dataset, name, keep: false)
		timestamp = Time.strptime(name, SnapFormat)
		self.new(dataset, name, timestamp, keep)
	rescue ArgumentError
		nil
	end

	def snapshot!
		name = Now.strftime(SnapFormat)
		ZFS.snapshot!(dataset, name, recurse: true)
		AutoSnapshot.parse(dataset, name)
	end
end

class Dataset
	attr_reader :dataset
	attr_reader :snapshots

	def initialize(dataset)
		@dataset = dataset
		@snapshotted = false
		@@snapshots ||= ZFS.snapshots
		@snapshots = @@snapshots[dataset].map {|s| AutoSnapshot.parse(s) }.compact.sort_by(&:timestamp)
	end

	def snapshot!(classes)
		@snapshotted ||= make_snapshot!
	end

	private
	def make_snapshot!(classes)
		name = Now.strftime(SnapFormat)
		ZFS.snapshot!(dataset, name, recurse: true)
		AutoSnapshot.parse(dataset, name, keep: true).tap {|as| @auto_snapshots.unshift as }
	end
end

# 3 snapshots at 15 minute intervals
# 8 at one hour intervals
# 7 at 1 day intervals
# 4 at 1 week intervals
snaptargets = [['15m', 3], ['1h', 8], ['1d', 7], ['1w', 4]]



SnapTarget = Struct.new(:name, :seconds, :count, :timespan, :snapshots)
targets = snaptargets.map do |interval, count|
	seconds = to_seconds(interval)
	SnapTarget.new(interval, seconds, count, Range.new(Time.at(Now - seconds * count), Time.at(Now - seconds)), [])
end.sort_by(&:seconds)

testsnaps = []


pp targets

ds = Dataset.new('backup')
targets.each do |target|
	if ds.snapshots.any? and ds.snapshots.first.timestamp <= target.timespan.last
		ds.snapshot!
	end
end
 ds.auto_snapshots

# snapshots = ZFS.snapshots
# ZFS.datasets(depth: 0).each do |dataset|
# 	snaps = snapshots[dataset]
# 	snapshotted = false

# 	if snaps.map! {|snap| AutoSnapshot.parse(dataset, snap) }.compact!.any?
# 		snaps.sort_by!(&:timestamp)
# 		targets.each do |target|
# 			if snaps.first.timestamp <= target.timespan.last and !snapshotted
# 				snaps.unshift AutoSnapshot.snapshot!(dataset)
# 				snaps.first.keep = true
# 				snapshotted = true
# 			end

# 			snaps.each do |snap|


# 			end
# 		end

# 	else
# 		auto_snapshot(dataset)
# 	end
# end