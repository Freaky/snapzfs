#!/usr/bin/env ruby

require 'optparse'
require 'time'
require 'pp'

if RUBY_VERSION.split(".").map(&:to_i)[0] < 2
	abort("Ruby version 2.0+ is required.")
end

# Options = <<EOC
# -n	--dry-run	Bla
# -v	--verbose	Print commands and other debug info
# EOC

# settings = {
# }

# OptionParser.new do |opts|
# 	opts.banner = "Usage: #{$0} [options] [interval[:number of snapshots] ..]"
# 	Options.each do |o|
# 		o = o.split(/\t+/)
# 		opts.on(*o) {|v| o[v[0]] = o }
# 	end
# end

TestSnapshots = []

module Snapper
	Now = Time.new

	module Command
		class Error < StandardError
		end

		def zfs(args)
			run([Which[:zfs], *args])
		end
		module_function :zfs

		def run(cmd)
			p cmd if $VERBOSE

			r,w = IO.pipe
			out = IO.popen(cmd, err: w){|f| f.read }
			w.close
			err = r.read || ''
			r.close

			if $?.success?
				return out || true
			else
				raise Error, "Error running #{cmd.join(' ').dump}, exit=#{$?.exitstatus}, stderr=\n#{err.gsub(/^/,"> ")}"
			end
		end
		module_function :run

		Which = Hash.new do |hash, cmd|
			exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
			ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
				exts.each { |ext|
					exe = File.join(path, "#{cmd}#{ext}")
					if File.executable? exe
						hash[cmd] = exe
						break
					end
				}
			end
			hash[cmd]
		end
	end

	class ZFS
		class << self
			#def auto_snapshot_property()    "com.sun:auto-snapshot" end
			def auto_snapshot_property()    "st.hur:auto-snapshot" end
			def snapshot_intervals_property() "st.hur:snapshot-intervals" end

			def managed_datasets
				datasets = list(type: %w(filesystem volume), properties: [snapshot_intervals_property, auto_snapshot_property])
				datasets.select {|name,props| props[auto_snapshot_property] == 'true' }
			end

			def managed_snapshots
				snapshots = list(type: 'snapshot', properties: ['used',snapshot_intervals_property])
				snapshots.select {|name, props| props[snapshot_intervals_property] != '-' }
			end

			def list(type: %w(filesystem volume), properties: %w())
				properties = ['name', 'type', *properties]
				op = %w(list -S name -H -o)
				op << properties.join(',')
				op += ['-t', Array(type).join(',')]
				datasets = Command.zfs(op).lines.map {|line| line.chomp.split("\t", properties.size) }
				Hash[datasets.map {|name,*props| [name, Hash[properties[1..-1].zip(props)]] }]
			end

			def empty_snapshots
				managed_snapshots.select {|name, props| props['used'] == '0' }
			end
		end
	end

	class Dataset
		def initialize(name)
		end

		def snapshots(interval=nil)
		end
	end

	def self.to_seconds(string)
		raise ArgumentError, "Invalid duration: #{string.dump}" unless md = /\A(\d+(?:\.\d+)?)([sSmhHdDwWMyY]?)\z/.match(string)
		num = Float(md[1])
		num *= case md[2]
		when ?m   then 60
		when /h/i then 60*60
		when /d/i then 60*60*24
		when /w/i then 60*60*24*7
		when ?M   then 60*60*24*31
		when /y/i then 60*60*24*365
		else 1
		end
	end

	Defaults = {
	}

	def self.run(args)
		intervals = {'15m' => 4, '1h' => 24, '1d' => 7, '1w' => 4}
		intervals = intervals.map do |interval, count|
			{interval: interval, seconds: to_seconds(interval), count: count, snapshots: []}
		end

		datasets  = ZFS.managed_datasets
		snapshots = ZFS.managed_snapshots

		snapshots_by_interval = 
		datasets.each do |name, props|
			props[:snapshots] = snapshots[name] || []
			props[:snapshots].each do |snapshot|
				intervals.assoc(snapshot['interval']).snapshots = snapshot
			end
		end

		new_snapshots = Hash.new {|h,k| h[k] = [] }
		intervals.each do |interval|
			datasets.each do |dataset|

			end
		end

		empty = ZFS.empty_snapshots
		pp empty



		p c
		p datasets
		p snapshots
	end
end


snapper = Snapper.run(ARGV)

exit

Now = Time.new

AutoSnapshot = Struct.new(:dataset, :name, :classes, :timestamp, :keep)
class AutoSnapshot
	SnapFormat = 'auto.%F.%R' # yyyy-mm-dd.hh:mm
	def initialize(dataset)
		@dataset = dataset
	end

	def self.parse(dataset, name, keep: false)
		timestamp = Time.strptime(name, SnapFormat)
		self.new(dataset, name, timestamp, keep)
	rescue ArgumentError
		nil
	end

	def snapshot!
		name = Now.strftime(SnapFormat)
		ZFS.snapshot!(dataset, name, recurse: true)
		AutoSnapshot.parse(dataset, name)
	end
end

class Dataset
	attr_reader :dataset
	attr_reader :snapshots

	def initialize(dataset)
		@dataset = dataset
		@snapshotted = false
		@@snapshots ||= ZFS.snapshots
		@snapshots = @@snapshots[dataset].map {|s| AutoSnapshot.parse(s) }.compact.sort_by(&:timestamp)
	end

	def snapshot!(classes)
		@snapshotted ||= make_snapshot!
	end

	private
	def make_snapshot!(classes)
		name = Now.strftime(SnapFormat)
		ZFS.snapshot!(dataset, name, recurse: true)
		AutoSnapshot.parse(dataset, name, keep: true).tap {|as| @auto_snapshots.unshift as }
	end
end

# 3 snapshots at 15 minute intervals
# 8 at one hour intervals
# 7 at 1 day intervals
# 4 at 1 week intervals
snaptargets = [['15m', 3], ['1h', 8], ['1d', 7], ['1w', 4]]



SnapTarget = Struct.new(:name, :seconds, :count, :timespan, :snapshots)
targets = snaptargets.map do |interval, count|
	seconds = to_seconds(interval)
	SnapTarget.new(interval, seconds, count, Range.new(Time.at(Now - seconds * count), Time.at(Now - seconds)), [])
end.sort_by(&:seconds)

testsnaps = []


pp targets

ds = Dataset.new('backup')
targets.each do |target|
	if ds.snapshots.any? and ds.snapshots.first.timestamp <= target.timespan.last
		ds.snapshot!
	end
end
 ds.auto_snapshots

# snapshots = ZFS.snapshots
# ZFS.datasets(depth: 0).each do |dataset|
# 	snaps = snapshots[dataset]
# 	snapshotted = false

# 	if snaps.map! {|snap| AutoSnapshot.parse(dataset, snap) }.compact!.any?
# 		snaps.sort_by!(&:timestamp)
# 		targets.each do |target|
# 			if snaps.first.timestamp <= target.timespan.last and !snapshotted
# 				snaps.unshift AutoSnapshot.snapshot!(dataset)
# 				snaps.first.keep = true
# 				snapshotted = true
# 			end

# 			snaps.each do |snap|


# 			end
# 		end

# 	else
# 		auto_snapshot(dataset)
# 	end
# end