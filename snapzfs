#!/usr/local/bin/ruby -w
#
# snapzfs: Yet another ZFS automatic management script.
#
# Distinguishing features?
#
# - Minimal deps.  Ruby and a few bits of stdlib, that's it. Distributed as one
#   file you can drop anywhere - nobody wants their backup system to fall over
#   because they upgraded bundler.
# - Avoids creating unnecessary snapshots:
#   - Different snapshot classes share snapshots.
#     e.g. tank@auto-2014-04-14.00:00Z can be an hourly, daily and weekly snapshot.
#   - Delete empty snapshots.  Only create new if written@last_snapshot is nonzero?
#     - need to update expiry time then.

if RUBY_VERSION.split(".").map(&:to_i)[0] < 2
	abort("Ruby version 2.0+ is required.")
end

require 'bigdecimal'
require 'optparse'
require 'pp'
require 'set'
require 'time'

module Snap
	module CommandRunner
		class Error < StandardError
		end

		def self.zfs(args)
			run([Which[:zfs], *args])
		end

		def self.run(cmd)
			p cmd if $VERBOSE

			r,w = IO.pipe
			out = IO.popen(cmd, err: w){|f| f.read }
			w.close
			err = r.read || ''
			r.close

			if $?.success?
				return out || true
			else
				raise Error, "Error running #{cmd.join(' ').dump}, exit=#{$?.exitstatus}, stderr=\n#{err.gsub(/^/,"> ")}"
			end
		end

		Which = Hash.new do |hash, cmd|
			exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
			ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
				exts.each { |ext|
					exe = File.join(path, "#{cmd}#{ext}")
					if File.executable? exe
						hash[cmd] = exe
						break
					end
				}
			end
			hash[cmd]
		end
	end

	module ZFS
		def self.property(name)
			"st.hur:snapshot.#{name}"
		end

		class Dataset
			class << self
				def properties() @properties ||= [] end
				def all_properties() @all_properties ||= Set.new end
				def property(name)
					properties << name
					Dataset.all_properties << name
				end

				def inherited(klass)
					properties.each {|prop| klass.property prop }
				end
			end

			property 'name'
			property 'type'
			property 'used'
			property ZFS.property :auto
			property ZFS.property :policy

			attr_reader :properties

			def name() self['name'] end

			def [](key) @properties[key] end

			def initialize(properties)
				@properties = properties
			end

			def destroy!
				ZFS.destroy self
			end
		end

		class Snapshottable < Dataset
			attr_accessor :snapshots

			def initialize(*)
				super
				@snapshots = []
			end

			def auto_snapshot?
				properties[ZFS.property :auto] != '-'
			end

			def auto_snapshots
				@auto_snapshots ||= snapshots.select(&:automatic?).sort_by(&:created_at)
			end

			class << self
				def policy_cache(policy) (@polices ||= {})[policy] ||= Interval.parse_intervals(policy) end
			end

			def policy
				unless (policy = properties[ZFS.property :policy]) == '-'
					Snapshottable.policy_cache(policy)
				end
			end

			# XXX We want to batch these up?
			def snapshot!(snapshot_name, properties = {})
				props = {}
				props[ZFS.property :intervals] = properties[:intervals].join(' ') if properties[:intervals]
				props[ZFS.property :created_at] = Integer(properties[:created_at]) or raise ArgumentError, "No creation time"
				props[ZFS.property :expires_at] = Integer(properties[:expires_at]) if properties[:expires_at]
				ZFS.snapshot("#{self.name}@#{snapshot_name}", props)
			end

			def written(since)
				Integer(ZFS.get_one(self.name, "written@#{since}"))
			end
		end

		class Filesystem < Snapshottable
			property 'mountpoint'
		end

		class Volume < Snapshottable
		end

		class Snapshot < Dataset
			property ZFS.property :expires_at
			property ZFS.property :created_at
			property ZFS.property :intervals #TODO: this should be :policy

			def inspect
				"#<Snapshot:#{object_id}: #{properties.inspect}>"
			end

			def automatic?
				properties[ZFS.property :created_at] != '-'
			end

			def expires_at
				if properties[ZFS.property :expires_at] != '-'
					@expires_at ||= Time.at(Integer(properties[ZFS.propert :expires_at])).gmtime
				end
			end

			def created_at
				@created_at ||= Time.at(Integer(properties[ZFS.property :created_at])).gmtime
			end

			def age(now)
				now.to_i - created_at.to_i
			end

			def intervals
				@intervals ||= Set.new(properties[ZFS.property :intervals].scan(/\d+/).map(&:to_i))
			end

			def snap_name
				name.split('@')[1]
			end

			def snapshot_of
				name.split('@').first
			end
		end

		class << self
			def get_one(dataset, property)
				op = %(zfs get -Hp -o value)
				op << property
				op << dataset
				CommandRunner.zfs(op)
			end

			def snapshot(name, properties)
				queued_snapshots[properties] << name
			end

			def destroy(dataset)
				queued_destroys << dataset
			end

			def commit!
				queued_snapshots.each do |properties, names|
					op = %w(snapshot)
					op += properties.map {|name,value| ['-o', "#{name}=#{value}"] }.flatten
					op += names
					if $dry
						pp op
					else
						CommandRunner.zfs(op)
					end
				end
				queued_snapshots.clear

				queued_destroys.group_by(&:snapshot_of).each do |dataset,snapshots|
					op = %w(destroy)
					op += ["#{dataset}@#{snapshots.map(&:snap_name).join(',')}"]
					if $dry
						pp op
					else
						CommandRunner.zfs(op)
					end
				end
				queued_destroys.clear
			end

			def queued_snapshots() @queued_snapshots ||= Hash.new{|h,k| h[k] = []} end
			def queued_destroys() @queued_destrots ||= [] end

			def list(type: %w(filesystem volume), properties: [])
				properties = ['name', 'type', *properties].uniq
				op = %w(list -S name -H -o)
				op << properties.join(',')
				op += ['-t', Array(type).join(',')] if type
				datasets = CommandRunner.zfs(op).lines.map {|line| line.chomp.split("\t", properties.size) }
				datasets.map {|props| Hash[properties.zip(props)] }
			end

			def datasets
				dsts = list(type: %w(filesystem volume snapshot), properties: Dataset.all_properties)
				dsts = dsts.group_by{|ds| ds['type'] }
				snapshottable = Hash[dsts.values_at('filesystem','volume').flatten.compact.map do |props|
					klass = props['type'] == 'filesystem' ? Filesystem : Volume
					[props['name'], klass.new(props)]
				end]

				dsts.fetch('snapshot', []).map {|props| Snapshot.new(props) }.each do |snapshot|
					snapshottable[snapshot.snapshot_of].snapshots << snapshot
				end
				return snapshottable
			end
		end
	end

	Interval = Struct.new(:raw, :seconds, :count)
	class Interval
		Periods = {
			1           => %w(s sec secs second seconds secondly),
			60          => %w(m min minute minutes minutely),
			3600        => %w(h hr hour hours hourly),
			3600*24     => %w(d dy day days daily),
			3600*24*7   => %w(wk week weeks weekly),
			3600*24*14  => %w(f fort fortnight fortnightly),
			3600*24*31  => %w(mn mon month months monthly),
			3600*24*356 => %w(y yr year years yearly),
		}

		PeriodRE = /(?:#{Periods.values.flatten.join('|')})/i
		PeriodMap = Periods.map.with_object({}) {|(k,v),h| v.each {|name| h[name] = k } }
		PeriodMap.default_proc = proc {|h,k| raise ArgumentError, "Invalid period: #{k.dump}" }

		def self.parse_intervals(string)
			used_intervals = Set.new
			string.split(/\s*;\s*/).map do |part|
				iv = case part
					# 5 weekly; 5 * weekly; weekly
				when /\A(\d+)?\s*\*?\s*(#{PeriodRE})\s*\z/i
					new(part, PeriodMap[$2.downcase], $1.nil? ? 1 : Integer($1))

					# 5 * 1 week; 5 * 6 week
				when /\A(\d+)\s*\*\s*(\d+(?:\.\d+)?)\s*(#{PeriodRE})\s*\z/i
					new(part, (PeriodMap[$3.downcase] * Float($2)).round, Integer($1))

				else
					raise ArgumentError, "Unable to parse interval: #{part.dump}"
				end
				raise ArgumentError, "Duplicate interval: #{part.dump}" if used_intervals.include? iv.seconds
				used_intervals << iv.seconds
				iv
			end
		end

		def cutoff(now)
			@cutoff ||= now - seconds * count
		end
	end

	class App
		attr_reader :options, :now

		Defaults = {
			prefix: 'auto.',
			format: '%F.%TZ',
			verbose: false,
			dry_run: false,
			policy: '4 * 1 minutes; 4 * 15 minutes; 24 hourly; 7 daily; 4 weekly; 4 monthly',
		}
		def self.run(args)
			new(args)
		end

		def initialize(args)
			@all_args = args
			args = args.dup

			@now = Time.new.gmtime

			@options = Defaults.dup

			case args.shift
			when 'auto'   then auto args
			when 'create' then create args
			when 'expire' then expire args
			when 'nuke'   then nuke args
			when 'list'   then list args
			when 'policy' then cmd_policy args
			when 'disable' then cmd_disable args
			when 'enable' then cmd_enable args
			else usage
			end
		end

		def d(txt = nil)
			puts txt if $VERBOSE
		end

		def datasets() @datasets ||= ZFS.datasets end

		def policy(dataset)
			dataset.policy || ZFS::Snapshottable.policy_cache(options[:policy])
		end

		def cmd_policy(args)
			if args.empty?
				managed_datasets.each do |dataset|
					puts " * #{dataset.name}: #{policy(dataset).map(&:raw).join('; ')}"
					policy(dataset).each do |pol|
						puts "    #{pol.raw}: #{pol.count} snapshots #{pol.seconds} (#{'%.2f' % (pol.seconds / 3600.0)} hours) apart"
					end
				end
				exit 0
			end

			spec = args.shift
			if spec == 'reset'
				args.each {|arg| CommandRunner.zfs(['inherit', ZFS.property(:policy), arg])}
				exit 0
			end

			begin
				policy = ZFS::Snapshottable.policy_cache(spec)
			rescue => e
				abort("Invalid policy specification: #{e.message}")
			else
				policy.each do |pol|
					puts "#{pol.raw}: #{pol.count} snapshots #{pol.seconds} (#{'%.2f' % (pol.seconds / 3600.0)} hours) apart"
				end
				args.each {|arg| CommandRunner.zfs(['set', "#{ZFS.property :policy}=#{spec}", arg])}
			end
		end

		def switch(args, bool)
			args.each {|arg| CommandRunner.zfs(['set', "#{ZFS.property :auto}=#{bool ? 'true' : 'false'}", arg])}
		end

		def cmd_enable(args)
			switch(args, true)
		end

		def cmd_disable(args)
			switch(args, false)
		end

		def managed_snapshots
			@managed_snapshots ||= datasets.values.map(&:auto_snapshots).flatten
		end

		def managed_datasets
			@managed_datasets ||= datasets.values.select(&:auto_snapshot?)
		end

		def list(args)
			managed_snapshots.each {|snapshot| puts snapshot.name }
		end

		def nuke(args)
			unless STDOUT.tty?
				puts "Nuke command is strictly interactive-only."
			end

			STDOUT.sync = true
			snapshots = managed_snapshots

			abort("No snapshots to nuke") if snapshots.empty?

			puts "WARNING: This command will destroy the following snapshots:"
			print "    ", snapshots.map(&:name).join("\n    ")
			puts

			confirmation = "destroy all the snapshots!"
			print "To continue, type: '#{confirmation}': "
			if STDIN.gets.chomp == confirmation
				snapshots.each(&:destroy!)
				ZFS.commit!
			else
				puts "Aborting"
			end
		end

		def snap_name
			@name ||= "#{options[:prefix]}#{now.strftime(options[:format])}"
		end

		def create(args)
			managed_datasets.each do |dataset|
				d "#{dataset.name}..."
				intervals = []
				snapshots = dataset.auto_snapshots
				policy(dataset).each do |iv|
					iv_snapshots = snapshots.select {|snapshot| snapshot.intervals.include? iv.seconds }
					if iv_snapshots.empty? or iv_snapshots.last.age(now) > iv.seconds
						intervals << iv.seconds
					end
				end

				extra = nil
				unless intervals.empty?
					while dataset.snapshots.any? {|snapshot| snapshot.snap_name == (snap_name + extra.to_s) }
						extra ||= '.0'
						extra.succ!
					end
					dataset.snapshot!(snap_name + extra.to_s, intervals: intervals, created_at: now)
				end
			end

			ZFS.commit!
		end

		def expire(args)
			datasets.each do |name, dataset|
				dataset.auto_snapshots.each do |snapshot|
					refs = 0

					policy(dataset).each do |iv|
						if snapshot.intervals.include?(iv.seconds) and iv.cutoff(now) <= snapshot.created_at
							refs += 1
						end
					end

					if refs.zero?
						if !(e = snapshot.expires_at) or e < now
							snapshot.destroy!
						end
					end
				end
			end

			ZFS.commit!
		end

		def auto(args)
			create args.dup
			expire args.dup
		end

		def usage
		end
	end
end

#pp Snap::ZFS.datasets
Snap::App.run(ARGV)