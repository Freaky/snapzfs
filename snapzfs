#!/usr/local/bin/ruby
#
# snapzfs: Yet another ZFS automatic management script.
#
# Distinguishing features?
#
# - Minimal deps.  Ruby and a few bits of stdlib, that's it. Distributed as one
#   file you can drop anywhere - nobody wants their backup system to fall over
#   because they upgraded bundler.
# - Uses ZFS user properties extensively.
# - Avoids creating unnecessary snapshots:
#   - Different snapshot classes share snapshots.
#     e.g. tank@auto-2014-04-14.00:00Z can be an hourly, daily and weekly snapshot.
#   - Delete empty snapshots.
#     - Only create new if written@last_snapshot is nonzero?
#       need to update expiry time then. Probably not worth it.

if RUBY_VERSION.split(".").map(&:to_i)[0] < 2
	abort("Ruby version 2.0+ is required.")
end

require 'bigdecimal'
require 'optparse'
require 'pp'
require 'set'
require 'time'

$dry = false

module Snap
	module CommandRunner
		class Error < StandardError
		end

		def self.zfs(args)
			run([Which[:zfs], *args])
		end

		def self.run(cmd)
			p cmd if $VERBOSE

			self.popen(cmd)
		end

		def self.xargs(cmd, args: [], items: [], xargs: [])
			cmd = [Which[:xargs], '-0', *xargs, Which[cmd], *args]
			p cmd if $VERBOSE

			self.popen(cmd) {|f| f.write(items.join("\000"))}
		end

		def self.popen(*args, &block)
			r,w = IO.pipe
			out = IO.popen(*args, 'a+', err: w) do |f|
				block.call(f) if block
				f.close_write
				f.read
			end
			w.close
			err = r.read || ''
			r.close

			if $?.success?
				return out || true
			else
				raise Error, "Error running #{cmd.join(' ').dump}, exit=#{$?.exitstatus}, stderr=\n#{err.gsub(/^/,"> ")}"
			end
		end

		Which = Hash.new do |hash, cmd|
			exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
			ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
				exts.each { |ext|
					exe = File.join(path, "#{cmd}#{ext}")
					if File.executable? exe
						hash[cmd] = exe
						break
					end
				}
			end
			hash[cmd]
		end
	end

	module ZFS
		def self.property(name)
			"st.hur:snapshot.#{name}"
		end

		class Dataset
			class << self
				def properties() @properties ||= [] end
				def all_properties() @all_properties ||= Set.new end
				def property(name)
					properties << name
					Dataset.all_properties << name
				end

				def inherited(klass)
					properties.each {|prop| klass.property prop }
				end
			end

			property 'name'
			property 'type'
			property 'used'
			property ZFS.property :auto
			property ZFS.property :policy

			attr_reader :properties

			def name() self['name'] end
			def used() Integer(self['used']) end

			def [](key) @properties[key] end

			def initialize(properties)
				@properties = properties
			end

			def destroy!
				ZFS.destroy self
			end
		end

		class Snapshottable < Dataset
			attr_accessor :snapshots

			def initialize(*)
				super
				@snapshots = []
			end

			def auto_snapshot?
				properties[ZFS.property :auto] != '-'
			end

			def auto_snapshots
				@auto_snapshots ||= snapshots.select(&:automatic?).sort_by(&:created_at)
			end

			class << self
				def policy_cache(policy) (@polices ||= {})[policy] ||= Policy.parse_policies(policy) end
			end

			def policy
				unless (policy = properties[ZFS.property :policy]) == '-'
					Snapshottable.policy_cache(policy)
				end
			end

			def snapshot!(snapshot_name, properties = {})
				props = {}
				props[ZFS.property :policies] = properties[:policies].join(' ') if properties[:policies]
				props[ZFS.property :created_at] = Integer(properties[:created_at]) or raise ArgumentError, "No creation time"
				props[ZFS.property :expires_at] = Integer(properties[:expires_at]) if properties[:expires_at]
				ZFS.snapshot("#{self.name}@#{snapshot_name}", props)
			end

			def written(since)
				Integer(ZFS.get_one(self.name, "written@#{since}"))
			end
		end

		class Filesystem < Snapshottable
			property 'mountpoint'
		end

		class Volume < Snapshottable
		end

		class Snapshot < Dataset
			property ZFS.property :expires_at
			property ZFS.property :created_at
			property ZFS.property :policies

			def inspect
				"#<Snapshot:#{object_id}: #{properties.inspect}>"
			end

			def automatic?
				properties[ZFS.property :created_at] != '-'
			end

			def expires_at
				if properties[ZFS.property :expires_at] != '-'
					@expires_at ||= Time.at(Integer(properties[ZFS.propert :expires_at])).gmtime
				end
			end

			def created_at
				@created_at ||= Time.at(Integer(properties[ZFS.property :created_at])).gmtime
			end

			def age(now)
				now.to_i - created_at.to_i
			end

			def policies
				@policies ||= Set.new(properties[ZFS.property :policies].scan(/\d+/).map(&:to_i))
			end

			def snap_name
				name.split('@')[1]
			end

			def snapshot_of
				name.split('@').first
			end
		end

		class << self
			def get_one(dataset, property)
				op = %(zfs get -Hp -o value)
				op << property
				op << dataset
				CommandRunner.zfs(op)
			end

			def snapshot(name, properties)
				queued_snapshots[properties] << name
			end

			def destroy(dataset)
				queued_destroys << dataset
			end

			def commit!
				queued_snapshots.each do |properties, names|
					op = %w(snapshot)
					op += properties.map {|name,value| ['-o', "#{name}=#{value}"] }.flatten
					#op += names
					if $dry
						pp op
					else
						CommandRunner.xargs(:zfs, args: op, items: names)
					end
				end
				queued_snapshots.clear

				queued_destroys.group_by(&:snapshot_of).each do |dataset,snapshots|
					op = %w(destroy)
					op += ["#{dataset}@#{snapshots.map(&:snap_name).join(',')}"]
					if $dry
						pp op
					else
						CommandRunner.zfs(op)
					end
				end
				queued_destroys.clear
			end

			def queued_snapshots() @queued_snapshots ||= Hash.new{|h,k| h[k] = []} end
			def queued_destroys() @queued_destrots ||= [] end

			def list(type: %w(filesystem volume), properties: [])
				properties = ['name', 'type', *properties].uniq
				op = %w(list -S name -H -o)
				op << properties.join(',')
				op += ['-t', Array(type).join(',')] if type
				datasets = CommandRunner.zfs(op).lines.map {|line| line.chomp.split("\t", properties.size) }
				datasets.map {|props| Hash[properties.zip(props)] }
			end

			def datasets
				dsts = list(type: %w(filesystem volume snapshot), properties: Dataset.all_properties)
				dsts = dsts.group_by{|ds| ds['type'] }
				snapshottable = Hash[dsts.values_at('filesystem','volume').flatten.compact.map do |props|
					klass = props['type'] == 'filesystem' ? Filesystem : Volume
					[props['name'], klass.new(props)]
				end]

				dsts.fetch('snapshot', []).map {|props| Snapshot.new(props) }.each do |snapshot|
					snapshottable[snapshot.snapshot_of].snapshots << snapshot
				end
				return snapshottable
			end
		end
	end

	Policy = Struct.new(:raw, :seconds, :count)
	class Policy # Rename Policy, support "midnight", "end of day", "start of month" etc?
		Periods = {
			1           => %w(s sec secs second seconds secondly),
			60          => %w(m min minute minutes minutely),
			3600        => %w(h hr hour hours hourly),
			3600*24     => %w(d dy day days daily),
			3600*24*7   => %w(wk week weeks weekly),
			3600*24*14  => %w(f fort fortnight fortnightly),
			3600*24*31  => %w(mn mon month months monthly),
			3600*24*356 => %w(y yr year years yearly),
		}

		PeriodRE = /(?:#{Periods.values.flatten.join('|')})/i
		PeriodMap = Periods.map.with_object({}) {|(k,v),h| v.each {|name| h[name] = k } }
		PeriodMap.default_proc = proc {|h,k| raise ArgumentError, "Invalid period: #{k.dump}" }

		def self.parse_policies(string)
			used_policies = Set.new
			string.split(/\s*;\s*/).map do |part|
				pol = case part
					# 5 weekly; 5 * weekly; weekly
				when /\A(\d+)?\s*\*?\s*(#{PeriodRE})\s*\z/i
					new(part, PeriodMap[$2.downcase], $1.nil? ? 1 : Integer($1))

					# 5 * 1 week; 5 * 6 week
				when /\A(\d+)\s*\*\s*(\d+(?:\.\d+)?)\s*(#{PeriodRE})\s*\z/i
					new(part, (PeriodMap[$3.downcase] * Float($2)).round, Integer($1))

				else
					raise ArgumentError, "Unable to parse interval: #{part.dump}"
				end
				raise ArgumentError, "Duplicate interval: #{part.dump}" if used_policies.include? pol.seconds
				used_policies << pol.seconds
				pol
			end
		end

		def cutoff(now)
			@cutoff ||= now - seconds * count
		end
	end

	class App
		attr_reader :options, :now

		Defaults = {
			prefix: 'auto.',
			format: '%FT%RZ',
			verbose: false,
			dry_run: false,
			policy: '4 * 1 minutes; 4 * 15 minutes; 24 hourly; 7 daily; 4 weekly; 4 monthly',
		}
		def self.run(args)
			new(args)
		end

		def initialize(args)
			@all_args = args
			args = args.dup

			@now = Time.new.gmtime

			@options = Defaults.dup

			case args.shift
			when 'auto'   then auto args
			when 'create' then create args
			when 'expire' then expire args
			when 'nuke'   then nuke args
			when 'list'   then list args
			when 'policy' then cmd_policy args
			when 'disable' then cmd_disable args
			when 'enable' then cmd_enable args
			when 'clean' then clear_empty_snapshots args
			else usage
			end
		end

		def d(txt = nil)
			puts txt if $VERBOSE
		end

		def datasets() @datasets ||= ZFS.datasets end
		def datasets_refresh() @datasets = ZFS.datasets end

		def policy(dataset)
			dataset.policy || ZFS::Snapshottable.policy_cache(options[:policy])
		end

		def cmd_policy(args)
			if args.empty?
				managed_datasets.each do |dataset|
					puts " * #{dataset.name}: #{policy(dataset).map(&:raw).join('; ')}"
					policy(dataset).each do |pol|
						puts "    #{pol.raw}: #{pol.count} snapshots #{pol.seconds} (#{'%.2f' % (pol.seconds / 3600.0)} hours) apart"
					end
				end
				exit 0
			end

			spec = args.shift
			if spec == 'reset'
				args.each {|arg| CommandRunner.zfs(['inherit', ZFS.property(:policy), arg])}
				exit 0
			end

			begin
				policy = ZFS::Snapshottable.policy_cache(spec)
			rescue => e
				abort("Invalid policy specification: #{e.message}")
			else
				policy.each do |pol|
					puts "#{pol.raw}: #{pol.count} snapshots #{pol.seconds} (#{'%.2f' % (pol.seconds / 3600.0)} hours) apart"
				end
				args.each {|arg| CommandRunner.zfs(['set', "#{ZFS.property :policy}=#{spec}", arg])}
			end
		end

		def switch(args, bool)
			args.each {|arg| CommandRunner.zfs(['set', "#{ZFS.property :auto}=#{bool ? 'true' : 'false'}", arg])}
		end

		def cmd_enable(args)
			switch(args, true)
		end

		def cmd_disable(args)
			switch(args, false)
		end

		def managed_snapshots
			@managed_snapshots ||= datasets.values.map(&:auto_snapshots).flatten
		end

		def managed_datasets
			@managed_datasets ||= datasets.values.select(&:auto_snapshot?)
		end

		def list(args)
			#print CommandRunner.zfs(['list', *args, *managed_datasets.map {|ds| [ds.name, ds.auto_snapshots.map(&:name)]}.flatten])
			print CommandRunner.xargs(:zfs, args: ['list', *args], items: managed_snapshots.map(&:name))
			#                          items: managed_datasets.map {|ds| [ds.name, ds.auto_snapshots.map(&:name)]}.flatten)
		end

		def nuke(args)
			unless STDOUT.tty?
				puts "Nuke command is strictly interactive-only."
			end

			STDOUT.sync = true
			snapshots = managed_snapshots

			abort("No snapshots to nuke") if snapshots.empty?

			puts "WARNING: This command will destroy the following snapshots:"
			print "    ", snapshots.map(&:name).join("\n    ")
			puts

			confirmation = "destroy all the snapshots!"
			print "To continue, type: '#{confirmation}': "
			if STDIN.gets.chomp == confirmation
				snapshots.each(&:destroy!)
				ZFS.commit!
			else
				puts "Aborting"
			end
		end

		def snap_name
			@name ||= "#{options[:prefix]}#{now.strftime(options[:format])}"
		end

		def create(args)
			managed_datasets.each do |dataset|
				d "#{dataset.name}..."
				policies = []
				snapshots = dataset.auto_snapshots
				policy(dataset).each do |pol|
					pol_snapshots = snapshots.select {|snapshot| snapshot.policies.include? pol.seconds }
					if pol_snapshots.empty? or pol_snapshots.last.age(now) > pol.seconds
						policies << pol.seconds
					end
				end

				extra = nil
				unless policies.empty?
					while dataset.snapshots.any? {|snapshot| snapshot.snap_name == (snap_name + extra.to_s) }
						extra ||= '.0'
						extra.succ!
					end
					dataset.snapshot!(snap_name + extra.to_s, policies: policies, created_at: now)
				end
			end

			ZFS.commit!
		end

		def expire(args)
			datasets.each do |name, dataset|
				dataset.auto_snapshots.each do |snapshot|
					refs = 0

					policy(dataset).each do |pol|
						if snapshot.intervals.include?(pol.seconds) and pol.cutoff(now) <= snapshot.created_at
							refs += 1
						end
					end

					if refs.zero?
						if !(e = snapshot.expires_at) or e < now
							snapshot.destroy!
						end
					end
				end
			end

			ZFS.commit!
		end

		def clear_empty_snapshots(args)
			datasets_refresh.each do |name, dataset|
				dataset.auto_snapshots.group_by(&:policies).each do |pol, snapshots|
					next if snapshots.size < 2
					snapshots[0..-2].select {|snapshot| snapshot.used.zero? }.each do |snapshot|
						d "empty: #{snapshot.name}"
						snapshot.destroy!
					end
				end
			end

			ZFS.commit!
		end

		def auto(args)
			create args.dup
			expire args.dup
		end

		def usage
		end
	end
end

Snap::App.run(ARGV)